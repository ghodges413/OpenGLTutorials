#version 450

// gimage* requires binding via glBindImageTexture
// sampler* requires binding via glBindTexture

// ImageStore/Load only works for pure textures.  It does not work for textures attached to an FBO.
// Textures that are attached to an FBO must be passed in as a sampler instead of as an image.


/*
==========================================================================================

This shader is a fork of clayjohn's awesome "Eroded Terrain Noise":
https://www.shadertoy.com/view/MtGcWh

==========================================================================================
*/

/*
==========================================================================================

Erosion parameters

==========================================================================================
*/

#define EROSION_TILES 4.0
#define EROSION_OCTAVES 5
#define EROSION_GAIN 0.5
#define EROSION_LACUNARITY 2.0

// Scale the input slope, leading to more erosion.
#define EROSION_SLOPE_STRENGTH 3.0
// Continuously modify the noise direction based on the previous fractal sample.
// This is what gives the slopes an interesting "branching" structure.
// A higher value will give you more branches.
#define EROSION_BRANCH_STRENGTH 3.0
// Maximum amount the erosion will modify the base height map
#define EROSION_STRENGTH 0.04

// Debug slider comparing the heightmap with and without erosion
#define COMPARISON_SLIDER

/*
==========================================================================================

The stuff below is not strictly related to the erosion effect

==========================================================================================
*/

#define PI 3.14159265358979f

// Base height noise parameters
#define HEIGHT_TILES 3.0f
#define HEIGHT_OCTAVES 3
#define HEIGHT_AMP 0.25f
#define HEIGHT_GAIN 0.1f
#define HEIGHT_LACUNARITY 2.0f

#define WATER_HEIGHT 0.45f

/*
================================
hash
================================
*/
vec2 hash( vec2 x ) {
    const vec2 k = vec2( 0.3183099f, 0.3678794f );
    x.x = x.x * k.x + k.y;
    x.y = x.y * k.y + k.x;

    vec2 k2 = k * 16.0f * fract( x.x * x.y * ( x.x + x.y ) );
    vec2 k3 = vec2( -1.0f, -1.0f ) + fract( k2 ) * 2.0f;
    return k3;
}

/*
================================
noised
// from https://www.shadertoy.com/view/XdXBRH
================================
*/
vec3 noised( vec2 p ) {
    vec2 i = floor( p );
    vec2 f = fract( p );

    vec2 f2;
    f2.x = f.x * ( f.x * 6.0f - 15.0f ) + 10.0f;
    f2.y = f.y * ( f.y * 6.0f - 15.0f ) + 10.0f;

    vec2 f3;
    f3.x = f.x * ( f.x - 2.0f ) + 1.0f;
    f3.y = f.y * ( f.y - 2.0f ) + 1.0f;

    vec2 u = f * f * f * f2;
    vec2 du = f * f * f3 * 30.0f;
    
    vec2 ga = hash( i + vec2( 0.0f, 0.0f ) );
    vec2 gb = hash( i + vec2( 1.0f, 0.0f ) );
    vec2 gc = hash( i + vec2( 0.0f, 1.0f ) );
    vec2 gd = hash( i + vec2( 1.0f, 1.0f ) );
    
    float va = dot( ga, f - vec2( 0.0f, 0.0f ) );
    float vb = dot( gb, f - vec2( 1.0f, 0.0f ) );
    float vc = dot( gc, f - vec2( 0.0f, 1.0f ) );
    float vd = dot( gd, f - vec2( 1.0f, 1.0f ) );

    float x = va + u.x * ( vb - va ) + u.y * ( vc - va ) + u.x * u.y * ( va - vb - vc + vd );
    vec2 yz = ga + u.x * ( gb - ga ) + u.y * ( gc - ga ) + u.x * u.y * ( ga - gb - gc + gd ) + du * ( vec2( u.y, u.x ) * ( va - vb - vc + vd ) + vec2( vb, vc ) - va );
    return vec3( x, yz.x, yz.y );
}



// code adapted from https://www.shadertoy.com/view/llsGWl
// name: Gavoronoise
// author: guil
// license: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
// Code has been modified to return analytic derivatives and to favour 
// direction quite a bit.

/*
================================
HeightSample
================================
*/
vec3 Erosion( vec2 p, vec2 dir ) {
    vec2 ip = floor( p );
    vec2 fp = fract( p );
    float f = 2.0f * PI;
    vec3 va = vec3( 0.0f, 0.0f, 0.0f );
    float wt = 0.0f;
    for ( int i = -2; i <= 1; i++ ) {
        for ( int j = -2; j <=1 ; j++ ) {
            vec2 o = vec2( i, j );
            vec2 h = hash( ip - o ) * 0.5f;
            vec2 pp = fp + o - h;
            float d = dot( pp, pp );
            float w = exp( -d * 2.0f );
            wt +=w;
            float mag = dot( pp, dir );
            vec2 yz = ( pp * 0.0f + dir ) * ( -sin( mag * f ) );
            va += vec3( cos( mag * f ), yz.x, yz.y ) * w;
        }
    }
    return va / wt;
}

/*
================================
HeightSample
================================
*/
vec2 Heightmap( vec2 uv ) {
    vec2 p = uv * HEIGHT_TILES;
    
    // FBM terrain
    vec3 n = vec3( 0.0f, 0.0f, 0.0f );
    float nf = 1.0;
    float na = HEIGHT_AMP;
    for ( int i = 0; i < HEIGHT_OCTAVES; i++ ) {
        n += noised( p * nf ) * na * vec3( 1.0, nf, nf );
        na *= HEIGHT_GAIN;
        nf *= HEIGHT_LACUNARITY;
    }
    
    // [-1, 1] -> [0, 1]
    n.x = n.x * 0.5f + 0.5f;
    
    // Take the curl of the normal to get the gradient facing down the slope
    vec2 dir = vec2( n.z, n.y ) * vec2( 1.0, -1.0 ) * EROSION_SLOPE_STRENGTH;
    
    // Now we compute another fbm type noise
    // erosion is a type of noise with a strong directionality
    // we pass in the direction based on the slope of the terrain
    // erosion also returns the slope. we add that to a running total
    // so that the direction of successive layers are based on the
    // past layers
    vec3 h = vec3( 0.0f, 0.0f, 0.0f );
    
    float a = 0.5f;
    float f = 1.0f;
    
    a *= smoothstep( WATER_HEIGHT - 0.1, WATER_HEIGHT + 0.2, n.x );

    int octaves = EROSION_OCTAVES;
    for ( int i = 0; i < octaves; i++ ) {
        h += Erosion( p * EROSION_TILES * f, dir + vec2( h.z, h.y ) * vec2( 1.0f, -1.0f ) * EROSION_BRANCH_STRENGTH ) * a * vec3( 1.0f, f, f);
        a *= EROSION_GAIN;
        f *= EROSION_LACUNARITY;
    }
    
    return vec2( n.x + ( h.x - 0.5f ) * EROSION_STRENGTH, h.x );
}

/*
================================
HeightSample
================================
*/
vec4 HeightSample( vec2 coord, float width ) {
    vec2 uv = coord;
    uv.x = coord.x / width;
    uv.y = coord.y / width;
    
    vec2 h = Heightmap( uv );
    
    // Calculate the normal from neighboring samples
    vec2 uv1 = uv + vec2( 1.0f, 0.0f ) * ( 1.0f / width );
    vec2 uv2 = uv + vec2( 0.0f, 1.0f ) * ( 1.0f / width );
    vec2 h1 = Heightmap( uv1 );
    vec2 h2 = Heightmap( uv2 );
    vec2 uva = uv1 - uv;
    vec2 uvb = uv2 - uv;
    vec3 v1 = vec3( uva.x, uva.y, ( h1.x - h.x ) );
    vec3 v2 = vec3( uvb.x, uvb.y, ( h2.x - h.x ) );
	v1 = normalize( v1 );
	v2 = normalize( v2 );
    vec3 normal = normalize( cross( v1, v2 ) );
    normal = vec3( normal.x, normal.z, normal.y );

    return vec4( h.x, normal.x, normal.z, h.y );
}

uniform int width;
uniform int tileX;
uniform int tileY;

layout ( binding = 0 ) uniform writeonly image2D destTex;

#define WORK_GROUP_SIZE 16
layout ( local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE, local_size_z = 1 ) in;

/*
 ==========================
 main
 ==========================
 */
void main() {
	ivec2 st = ivec2( gl_GlobalInvocationID.xy );
	if ( st.x < width && st.y < width ) {
		float x = st.x;
		float y = st.y;
	
		vec2 coord;
		coord.x = x + tileX * ( width - 1 ); // The -1 is to prevent an "off by 1" error in the sampling,
		coord.y = y + tileY * ( width - 1 ); // otherwise tiles won't line up properly
		vec4 color = HeightSample( coord, width );

		imageStore( destTex, st, color );
	}
}
 
 