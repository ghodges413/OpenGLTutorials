#version 450


struct fluid_t {
	vec3 pos;
	float pad0;

	vec3 vel;
	float pressure;

	vec3 posOld;
	float density;
};

layout( std430, binding = 0 ) buffer fluidParticles {
	fluid_t particles[];
};

struct elem_t {
	int idx;
	int key;
};

layout( std430, binding = 1 ) buffer elements {
	elem_t sorted[];
};

layout( std430, binding = 2 ) buffer starts {
	int startIndices[];
};

#define WORK_GROUP_SIZE 128
layout ( local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1 ) in;

uniform int MAX_PARTICLES;
uniform int NUM_CELLS;
uniform float PARTICLE_RADIUS;

uniform float TARGET_DENSITY;
uniform float SPEED_OF_SOUND;
uniform float PRESSURE_GAMMA;


#define FS_PI 3.1415f

#define GRID_SPACING PARTICLE_RADIUS

uniform int RESOLUTION_X;
uniform int RESOLUTION_Y;
uniform int RESOLUTION_Z;

#define NUM_CELLS ( RESOLUTION_X * RESOLUTION_Y * RESOLUTION_Z )

/*
====================================
GetGridPos
====================================
*/
ivec3 GetGridPos( vec3 pos ) {
	ivec3 v;
	v.x = int( pos.x / GRID_SPACING );
	v.y = int( pos.y / GRID_SPACING );
	v.z = int( pos.z / GRID_SPACING );
	return v;
}

/*
====================================
GetHashKeyFromBucketIndex
====================================
*/
int GetHashKeyFromBucketIndex( ivec3 idx ) {
	ivec3 idx2 = idx;

	idx2.x = idx.x % RESOLUTION_X;
	idx2.y = idx.y % RESOLUTION_Y;
	idx2.z = idx.z % RESOLUTION_Z;

	if ( idx2.x < 0 ) {
		idx2.x += RESOLUTION_X;
	}
	if ( idx2.y < 0 ) {
		idx2.y += RESOLUTION_Y;
	}
	if ( idx2.z < 0 ) {
		idx2.z += RESOLUTION_Z;
	}

	int key = idx2.x + RESOLUTION_X * ( idx2.y + RESOLUTION_Y * idx2.z );
	return key;
}

/*
====================================
GetHashKeyFromPosition
====================================
*/
int GetHashKeyFromPosition( vec3 pos ) {
	ivec3 idx = GetGridPos( pos );
	return GetHashKeyFromBucketIndex( idx );
}

/*
====================================
GetNearbyKeys
====================================
*/
void GetNearbyKeys( vec3 pos, out int nearbyKeys[ 27 ] ) {
	ivec3 idx = GetGridPos( pos );
	ivec3 nearbyBucketIndices[ 3 * 3 * 3 ];

	for ( int z = 0; z < 3; z++ ) {
		for ( int y = 0; y < 3; y++ ) {
			for ( int x = 0; x < 3; x++ ) {
				int i = x + 3 * y + ( 3 * 3 * z );
				nearbyBucketIndices[ i ] = idx;
				nearbyBucketIndices[ i ].x += x - 1;
				nearbyBucketIndices[ i ].y += y - 1;
				nearbyBucketIndices[ i ].z += z - 1;
			}
		}
	}

	for ( int i = 0; i < 27; i++ ) {
		nearbyKeys[ i ] = GetHashKeyFromBucketIndex( nearbyBucketIndices[ i ] );
	}
}

/*
==========================
Kernel_SL_smooth
==========================
*/
float Kernel_SL_smooth( float x ) {
#if 0
	float s = PARTICLE_RADIUS;
	if ( x >= s ) {
		return 0;
	}

	// spikey
	float volume = ( FS_PI * pow( s, 4 ) ) / 6.0f;
	float kernel = ( s - x ) * ( s - x ) / volume;
	return kernel;
#else
	float h = PARTICLE_RADIUS;

	float r = x;//( a - pos ).GetMagnitude();
	if ( r >= h ) {
		return 0.0f;
	}

	float h3 = h * h * h;

	float constant = 15.0f / ( FS_PI * h3 );
	float numerator = 1.0f - r / h;
	float num3 = numerator * numerator * numerator;

	float W = constant * num3;
	return W;
#endif
}

/*
==========================
Density_SL
==========================
*/
float Density_SL( vec3 pt, int skip ) {
	const float mass = 1;
	float density = 0;

	int neighborKeys[ 27 ];
	GetNearbyKeys( particles[ skip ].pos, neighborKeys );

	// Loop over the 3x3x3 cube of grid cells to find neighbors
	for ( int k = 0; k < 27; k++ ) {
		int key = neighborKeys[ k ];
		int start = startIndices[ key ];
		if ( start >= MAX_PARTICLES ) {
			continue;
		}

		// Loop over neighbors in this cell
		for ( int j = start; j < MAX_PARTICLES; j++ ) {
			if ( key != sorted[ j ].key ) {
				break;
			}

			int idx = sorted[ j ].idx;
			if ( idx == skip ) {
				continue;
			}
			fluid_t particle = particles[ idx ];
			float dist = length( pt - particle.pos );
			float influence = Kernel_SL_smooth( dist );
			density += mass * influence;
		}
	}

	if ( density < TARGET_DENSITY ) {
		density = TARGET_DENSITY;
	}
	return density;
}

float Density( const int i ) {
	const float mass = 1;
	float density = 0;

	int neighborKeys[ 27 ];
	GetNearbyKeys( particles[ i ].pos, neighborKeys );

	// Loop over the 3x3x3 cube of grid cells to find neighbors
	for ( int k = 0; k < 27; k++ ) {
		int key = neighborKeys[ k ];
		int start = startIndices[ key ];
		if ( start >= MAX_PARTICLES ) {
			continue;
		}

		// Loop over neighbors in this cell
		for ( int j = start; j < MAX_PARTICLES; j++ ) {
			if ( key != sorted[ j ].key ) {
				break;
			}

			int idx = sorted[ j ].idx;
			if ( idx == i ) {
				continue;
			}

			vec3 xi = particles[ i ].pos;
			vec3 xj = particles[ idx ].pos;
			float dist = length( xi - xj );
			//float weight = PARTICLE_MASS * Kernel_Spiky( dist );
			float weight = mass * Kernel_SL_smooth( dist );
			density += weight;
		}
	}

	if ( density < TARGET_DENSITY ) {
		density = TARGET_DENSITY;
	}
	return density;
}

/*
====================================
PressureEOS
====================================
*/
float PressureEOS( float density, float targetDensity, float eosScale, float eosExponent, float negativePressureScale ) {
	float p = eosScale / eosExponent * ( pow( ( density / targetDensity ), eosExponent ) - 1.0f );
	
	if ( p < 0 ) {
		p *= negativePressureScale;
	}

	return p;
}

/*
====================================
Pressure
====================================
*/
float Pressure( const int i ) {
	float p = 0;

	float di = particles[ i ].density;

	float targetDensity = TARGET_DENSITY;
	float eosScale = targetDensity * SPEED_OF_SOUND * SPEED_OF_SOUND / PRESSURE_GAMMA;

	p = PressureEOS( di, targetDensity, eosScale, PRESSURE_GAMMA, 0.0f );
	return p;
}

/*
==========================
main
==========================
*/
void main() {
	int thread_id = int( gl_GlobalInvocationID.x );
	if ( thread_id >= MAX_PARTICLES ) {
		return;
	}

	particles[ thread_id ].density = Density( thread_id );
	particles[ thread_id ].pressure = Pressure( thread_id );
}
